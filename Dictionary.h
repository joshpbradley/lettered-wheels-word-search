#pragma once

#include <string>
#include <array>
#include <memory>

#include "Utils.h"

/**
 * This structure represents a dictionary and is used to cross-reference words generated by the lettered wheels.
 * 
 * All words are expected to be in the range [a-z][A-Z] and only the words 2 <= {word length} <= letters_per_wheel are inserted.
 * Words are expected to be formatted on a new line.
 */
class Dictionary
{
    /**
     * A single node in the Dictionary data structure, and represents an individual character.
     * A node is comprised of an array of 26 Node pointers, that when filled at a particular index, indicates
     * a subsequent letter in a string.
     */
    class Node
    {
        // Allows the Dictionary class to access all private members of the inner Node class.
        friend class Dictionary;

      private:
        // Initialies the Node poiters to nullptr.
        std::array<std::unique_ptr<Node>, Utils::LETTERS_IN_ALPHABET> letters = {};
        // True if this node is the end node in a word, else false.
        bool isWord = false;
        // True if this node is the final node in the chain.
        // This implies the path generated to reach the node is a word, and that all nodes in its array are null.
        bool isTerminal = true;

        std::array<std::unique_ptr<Node>, Utils::LETTERS_IN_ALPHABET>& GetArray();
        bool getIsWord(void) const;
        void setIsWord(bool b);
        bool getIsTerminal(void) const;
        void setIsNotTerminal(void);
    };

  public:
      /**
       * These values represent the result states of a search in the Dictionary structure (using find(std::string word)).
       * HIT_TERMINAL = a word has been found, and the final node is a terminal node in the Dictionary.
       * HIT_PARENT = a word has been found, and the final node is a parent node.
       * MISS_PARENT = a word has not been found, and the final node is a parent node.
       * MISS = a word could not be found and somewhere in the search a null node was inspecting - indicating an absence from the Dictionary.
       */
      enum SEARCH_STATUS
      {
         HIT_TERMINAL,
         HIT_PARENT,
         MISS_PARENT,
         MISS
      };

      /**
       * Default constructor.
       */
      Dictionary(void);
      /**
       * Constructor that inserts words from the provided dictionary .txt file.
       * The words added must be in the range: 2 <= {word length} <= maximumWordSize. 
       * 
       * @param file: the dictionary .txt file to encode
       * @param maximumWordSize: the maximum length of words that will be stored
       */
      Dictionary(std::ifstream& file, size_t maximumWordSize);
      /**
       * Inserts a new word in the dictionary.
       * 
       * @param word: the word to insert in the dictionary.
       */
      void insert(const std::string& word) const;
      /**
       * Attempts to find a word in the dictionary.
       * 
       * @param word: the word to search for in the dictionary
       * @return the status of the search. See the SEARCH_STATUS enum for more information on the possible return values.
       */
      SEARCH_STATUS find(const std::string& word);

  private:
    // The root node in the dictionary. This is the only node that does not represent a character in a word.
    const std::unique_ptr<Node> root;
};
